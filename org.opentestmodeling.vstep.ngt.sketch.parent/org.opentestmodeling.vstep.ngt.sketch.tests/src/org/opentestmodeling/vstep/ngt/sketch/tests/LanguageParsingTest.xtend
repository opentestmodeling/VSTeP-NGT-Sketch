/*
 * generated by Xtext 2.15.0
 */
package org.opentestmodeling.vstep.ngt.sketch.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.opentestmodeling.vstep.ngt.sketch.language.Model

@ExtendWith(InjectionExtension)
@InjectWith(LanguageInjectorProvider)
class LanguageParsingTest {
	@Inject
	ParseHelper<Model> parseHelper
	@Test
	def void loadTestComment() {
		val result = parseHelper.parse('''
			/*
			 * Multi-line style comment
			 */

			// One-line style comment
		''')
		Assertions.assertNull(result)
	}

	@Test
	def void loadTestTarget() {
		val result = parseHelper.parse('''

			(Test target)
			(TestTarget)
			(テスト対象❤) // 16bit Unicode acceptable
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestViewpoint() {
		val result = parseHelper.parse('''

			[Test Viewpoint]
			[TestViewpoint]
			[テスト観点❤] // 16bit Unicode acceptable

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestViewpointDetailed() {
		val result = parseHelper.parse('''

			[WinNT variants 1]
			[WinNT variants 2] { "all" }
			[WinNT variants 3] {
				quality-risk {
					importance=10
					severity=5
				}
			}
			[WinNT variants 4] {
				items { "2K" "XP" "VS" "7" "8" "10" }
			}
			[WinNT variants 5] {
				items { "2K" "XP" "VS" "7" "8" }
				quality-risk {
					importance=10
					severity=5
				}
				"all"
			}

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}


	@Test
	def void loadTestShortDesc() {
		val result = parseHelper.parse('''

			/* The short description can be used as a comment.
			 * Short descriptions are contained in the model.
			 * So code generators can use short descriptions.
			 * (Regular comments are just ignored by the parser and not stored in the model)
			 * This is the point that modelers use short descriptions instead of comments.
			 */
			[Viewpoint A] "This is a short description"

			[Viewpoint with stereotype] <<stereotype>> "This is a short description"

			[The order can be changed] "This is a short description" <<stereotype>>

			[The detail must be the tail] "This is a short description" { "all" }

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestInheritance() {
		val result = parseHelper.parse('''

			(Test Target)  <|--  [Test Viewpoint]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestInheritanceWithPrototype() {
		val result = parseHelper.parse('''

			(TestTarget)  <|-<<Prototype>>-  [TestViewpoint]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestRecursiveInheritanceWithPrototype() {
		val result = parseHelper.parse('''

			(Target) <|-- [Viewpoint A]  <|-<<Prototype>>- [Viewpoint B]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestMultiInheritance() {
		val result = parseHelper.parse('''

			(Target) <|-- [Viewpoint A]
			(Target) <|-- [Viewpoint B]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestInvalidInheritance() {
		val result = parseHelper.parse('''

			/* Must be failed as test targets can't be inherited from any viewpoints. */
			[Viewpoint] <|-- (Target)

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertFalse(errors.isEmpty)
		Assertions.assertEquals(errors.join(""), "XtextSyntaxDiagnostic: null:3 no viable alternative at input '(Target)'")
	}

	@Test
	def void loadTestRelation() {
		val result = parseHelper.parse('''

			(Target) .... [Viewpoint A]
			[Viewpoint B] .... (Target)
			(Target) ..<<stereotype>>.. [Viewpoint B] .... [Viewpoint C]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestDependency() {
		val result = parseHelper.parse('''

			(Target) <-- [Viewpoint A]
			[Viewpoint B] <-- (Target)
			[Viewpoint A] <-<<stereotype>>- [Viewpoint B] <-- [Viewpoint C]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestIDsEscaped() {
		val result = parseHelper.parse('''

			/* '\' is a esape character. Similar rule in Xtext's STRING. */ 
			(Escaped \) Target)
			[Escaped \] Viewpoinrt]
			(Target) <<Escaped \> Stereotype>>

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestTopLebelImport() {
		val result = parseHelper.parse('''

			import "dummyURI"

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void loadTestContainer() {
		val result = parseHelper.parse('''

			container hogehoge {
				container foobar {
					(hogehoge) <|-- [fugaguga]
					[fugafuga] <|-- [hogehoge]
				}
			}

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')

	}

	@Test
	def void loadTestParallelChain() {
		val result = parseHelper.parse('''

			/* `+` means share the upstream node. */
			(hogehoge) <|-- + [fugaguga]
			                + [bar]
			                + [baz] <|-- + [baz1]
			                             + [baz1]

		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')

	}

	@Test
	def void loadTestReference() {
		val result = parseHelper.parse('''

			[a]
			[b]

			/* `&` prefix means 'reference'.
			 * The prefixed node must be linked to the another node that have same ID.
			 */
			& [b] <-- [c]
			[c] <-- &[a]

			/* You can write nodes without `&` like below */
			[b] <-- [c]
			/* Because the post processor merges that have same ID. */

			/* But the modeler will get mertis by using `&`.
			 * The language parser will check if the modeler using undefined node.
			 * And the editor can help him by the content assist.
			 * I recommend to use `&` prefix for more strict models.
			 */
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')

	}


}
